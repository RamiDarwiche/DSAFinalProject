<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shortest Path Finder</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
    <div id="map"></div>
    <div class="instructions" id="instructions">
        <h2 id="current-instruction">test</h2>
    </div>
    <button class="clear-button" id="clear-button">Clear Selections</button>
    <button class="display-times" id="display-times">Display Algorithm Comparisons</button>
    <div class="display-times-container">
        <span id="close">x</span>
        <h1>Algorithm Comparisons</h1>
        <section class="algorithm-time" id="shortest-path">
            <h2>Shortest Path</h2>
            <p>Time: <span id="shortest-path-time"></span></p>
        </section>
        <section class="algorithm-time" id="dijkstras">
            <h2>Dijkstra's</h2>
            <p>Time: <span id="dijkstras-time"></span></p>
        </section>
        <section class="algorithm-time" id="idk-path">
            <h2>idk</h2>
            <p>Time: <span id="idk-path-time"></span></p>
        </section>
    </div>


    <script>
        // figure out what to do with bounding and max zoom
        const gVilleBottomLeft = L.latLng(29.590916, -82.403343);
        const gVilleTopRight = L.latLng(29.709964, -82.253311);
        //        const gVilleTopRight = L.latLng(29.84868424409252,-82.01843261718751);

        const mapBounds = L.latLngBounds(gVilleBottomLeft, gVilleTopRight);

        const map = L.map('map', {maxBounds: mapBounds}).setView([29.651634, -82.324826], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
            minZoom: 12.5
        }).addTo(map);

        let pointA, pointB;
        const markers = [];
        let pathLine = null;

        // set first instruction
        if(!pointA) {
            document.getElementById('current-instruction').innerHTML = "Click anywhere to select a starting point";
            document.getElementById('shortest-path-time').innerHTML = 'No time found';
        }

        // allow for dragging?
        // clean up code
        map.on('click', function(e) {
            const { lat, lng } = e.latlng;
            if (!pointA) {
                pointA = [lat, lng];
                console.log("Point A: " + pointA)
                // set second instruction after first marker placed
                document.getElementById('current-instruction').innerHTML = "Click anywhere to select an ending point";
                let popUpA = L.popup({autoClose: false, closeOnClick: false, closeButton: false, content: "<h4>Point A</h4>"});
                const markerA = L.marker(pointA).addTo(map).bindPopup(popUpA).openPopup();
                markers.push(markerA);
            } else if (!pointB) {
                pointB = [lat, lng];
                console.log("Point B: " + pointB);
                // TODO: fix const iconB = L.icon({ iconUrl: 'assets/orangeMarker.png', iconSize: [30, 36] });
                document.getElementById('instructions').style.display = 'none';
                let popUpB = L.popup({autoClose: false, closeOnClick: false, closeButton: false, content: "<h4>Point B</h4>"});
                const markerB = L.marker(pointB).addTo(map).bindPopup(popUpB).openPopup();
                markers.push(markerB);

                fetch('/shortest_path', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pointA, pointB })
                })
                .then(response => response.json())
                .then(data => {
                    const pathCoordsShortest = data.path_shortest;
                    const shortestPathTimer = data.time_shortest;
                    const pathCoordsDijkstras = data.path_dijkstras;
                    const dijkstrasTimer = data.time_dijkstras;

                    if(shortestPathTimer) {
                        document.getElementById('shortest-path-time').innerHTML = shortestPathTimer;
                    }
                    if(dijkstrasTimer) {
                        document.getElementById('dijkstras-time').innerHTML = dijkstrasTimer;
                    }

                    console.log(shortestPathTimer)

                    if (pathLine) map.removeLayer(pathLine); // Remove previous path if any
                    pathLine = L.polyline(pathCoordsShortest, { color: 'blue', weight: 5  }).addTo(map);

                    const padding = L.point(300, 300);
                    map.fitBounds(pathLine.getBounds(), {padding});
                });
            } else {
                alert("You have already selected Point A and Point B.");
            }
        });

        // resets markers, instructions, and algorithm comparison panel
        document.getElementById('clear-button').addEventListener('click', () => {
            markers.forEach(marker => map.removeLayer(marker));
            markers.length = 0;

            if (pathLine) map.removeLayer(pathLine);

            pointA = null;
            pointB = null;
            document.getElementById('instructions').style.display = 'block';
            document.getElementById('current-instruction').innerHTML = "Click anywhere to select a starting point";
            document.getElementById('shortest-path-time').innerHTML = 'No time found';
        });

        // open and close algorithm comparison panel
        document.getElementById('display-times').addEventListener('click', () => {
            const displayTimesContainer = document.querySelector('.display-times-container');

            if (displayTimesContainer.style.display === 'block') {
                displayTimesContainer.style.display = 'none';
            } else {
                displayTimesContainer.style.display = 'block';
            }
        });

        document.getElementById('close').addEventListener('click', () => {
            const displayTimesContainer = document.querySelector('.display-times-container');
            displayTimesContainer.style.display = 'none';
        });
    </script>
</body>
</html>
